#!/usr/bin/python
#
# A GUI configurator for generating Fetchmail configuration files
# by Eric S. Raymond, <esr@snark.thyrsus.com>.  Requires Python with Tkinter.

from Tkinter import *
from Dialog import *
import sys
import time
import os
import string

#
# Define the data structures the GUIs will be tossing around
#
class Controls:
    def __init__(self):
	self.poll_interval = 300	# Default to 5-minute timeout
	self.syslog = FALSE		# Use syslogd for logging?
	self.logfile = None		# No logfile, initially
	self.idfile = os.environ["HOME"] + "/.fetchids"		# Default idfile, initially
	self.invisible = FALSE		# Suppress Received line & spoof?
	self.servers = []		# List of included sites
	Controls.typemap = (
	    ('poll_interval',	'String'),
	    ('syslog',		'Boolean'),
	    ('logfile',		'String'),
	    ('idfile',		'String'),
	    ('invisible',	'Boolean'))

    def __repr__(self):
	str = "";
	if self.syslog != ControlDefaults.syslog:
	   str = str + ("set syslog\n")
	elif self.logfile:
	    str = str + ("set logfile \"%s\"\n" % (self.logfile,));
	if self.idfile != ControlDefaults.idfile:
	    str = str + ("set idfile \"%s\"\n" % (self.idfile,));
	if self.poll_interval != ControlDefaults.poll_interval:
	    str = str + ("set daemon %s\n" % (self.poll_interval,))
	for site in self.servers:
	    str = str + repr(site)
	return str

    def __str__(self):
	return "[Controls: " + repr(self) + "]"

class Server:
    def __init__(self):
	self.pollname = None		# Poll label
	self.via = None			# True name of host
	self.active = TRUE		# Poll status
	self.interval = 0		# Skip interval
	self.protocol = 'auto'		# Default to auto protocol
	self.port = 0			# Port number to use
	self.uidl = FALSE		# Don't use RFC1725 UIDLs by default
	self.auth = 'password'		# Default to password authentication
	self.timeout = 300		# 5-minute timeout
	self.envelope = 'Received'	# Envelope-address header
	self.envskip = 0		# Number of envelope headers to skip
	self.qvirtual = None		# Name prefix to strip
	self.aka = []			# List of DNS aka names
	self.dns = TRUE			# Enable DNS lookup on multidrop
	self.localdomains = []		# Domains to be considered local
	self.interface = None		# IP address and range
	self.monitor = None		# IP address and range
	self.users = []			# List of user entries for site
	Server.typemap = (
	    ('pollname',  'String'),
	    ('via',       'String'),
	    ('active',    'Boolean'),
	    ('interval',  'Int'),
	    ('protocol',  'String'),
	    ('interval',  'Int'),
	    ('port',      'Int'),
	    ('uidl',      'Boolean'),
	    ('auth',      'String'),
	    ('timeout',   'Int'),
	    ('envelope',  'String'),
	    ('envskip',   'Int'),
	    ('qvirtual',  'String'),
	    # leave aka out
	    ('dns',       'Boolean'),
	    # leave localdomains out
	    ('interface', 'String'),
	    ('monitor',   'String'))

    def dump(self, folded):
	str = ""
	if self.active:   str = str + "poll"
	else:             str = str + "skip"
	str = str + (" " + self.pollname)
	if self.via:
	    str = str + " via " + self.via
	if self.protocol != ServerDefaults.protocol:
	    str = str + " with proto " + self.protocol 
	if self.port != defaultports[self.protocol] and self.port != 0:
	    str = str + " port " + `self.port`
	if self.timeout != ServerDefaults.timeout:
	    str = str + " timeout " + `self.timeout`
	if self.interval != ServerDefaults.interval: 
	    str = str + " interval " + `self.interval`
	if self.envelope != ServerDefaults.envelope or self.envskip != ServerDefaults.envskip:
	    if self.envskip:
		str = str + " envelope " + self.envskip + " " + self.envelope
	    else:
		str = str + " envelope " + self.envelope
	if self.qvirtual != ServerDefaults.qvirtual:
	    str = str + " qvirtual " + self.qvirtual
	if self.auth != ServerDefaults.auth:
	    str = str + " auth " + self.auth
	if self.dns != ServerDefaults.dns or self.uidl != ServerDefaults.uidl:
	    str = str + " and options"
	if self.dns != ServerDefaults.dns:
	    str = str + flag2str(self.dns, 'dns')
	if self.uidl != ServerDefaults.uidl:
	    str = str + flag2str(self.uidl, 'uidl')
	if folded:        str = str + "\n    "
	else:             str = str + " "

	if self.aka:
	     str = str + "aka"
	     for x in self.aka:
		str = str + " " + x
	if self.aka and self.localdomains: str = str + " "
	if self.localdomains:
	     str = str + ("localdomains")
	     for x in self.localdomains:
		str = str + " " + x
        if (self.aka or self.localdomains):
	    if folded:
		str = str + "\n    "
	    else:
		str = str + " "

	if self.interface: str = str + "interface " + self.interface
	if self.monitor: str = str + "monitor " + self.monitor
	if (self.interface or self.monitor):
	    if folded:
		str = str + "\n"

	if str[-1] == " ": str = str[0:-1]

	for user in self.users:
	    str = str + repr(user)
	str = str + "\n"
	return str;

    def __repr__(self):
	return self.dump(TRUE)

    def __str__(self):
	return "[Server: " + self.dump(FALSE) + "]"

class User:
    def __init__(self):
	self.remote = ""		# Remote username
	self.localnames = None		# Local names
	self.password = ""		# Password for mail account access
	self.mailboxes = None		# Remote folders to retrieve from
	self.smtphunt = None		# Hosts to forward to
	self.smtpaddress = None;	# Append this to MAIL FROM line
	self.preconnect = ""		# Connection setup
	self.postconnect = ""		# Connection wrapup
	self.mda = ""			# Mail Delivery Agent
	self.antispam = 571;		# Listener's spam-block code
	self.keep = FALSE		# Keep messages
	self.flush = FALSE		# Flush messages
	self.fetchall = FALSE		# Fetch old messages
	self.rewrite = TRUE		# Rewrite message headers
	self.forcecr = FALSE		# Force LF -> CR/LF
	self.stripcr = FALSE		# Strip CR
	self.pass8bits = FALSE		# Force BODY=7BIT
	self.mimedecode = FALSE		# Undo MIME armoring
	self.dropstatus = FALSE		# Drop incoming Status lines
	self.limit = 0			# Message size limit
	self.fetchlimit = 0		# Max messages fetched per batch
	self.batchlimit = 0		# Max message forwarded per batch
	self.expunge = 1		# Interval between expunges (IMAP)
	User.typemap = (
	    ('remote',      'String'),
	    # leave out mailboxes and localnames
	    ('password',    'String'),
            # Leave out smtphunt
	    ('smtpaddress',  'String'),
	    ('preconnect',  'String'),
	    ('postconnect', 'String'),
	    ('mda',         'String'),
	    ('antispam',    'Int'),
	    ('keep',        'Boolean'),
	    ('flush',       'Boolean'),
	    ('fetchall',    'Boolean'),
	    ('rewrite',     'Boolean'),
	    ('forcecr',     'Boolean'),
	    ('stripcr',     'Boolean'),
	    ('pass8bits',   'Boolean'),
	    ('mimedecode',  'Boolean'),
	    ('dropstatus',  'Boolean'),
	    ('limit',       'Int'),
	    ('fetchlimit',  'Int'),
	    ('batchlimit',  'Int'),
	    ('expunge',     'Int'))

    def __repr__(self):
	str = "    "
	str = str + "user " + self.remote + " there ";
	if self.password: str = str + "with password " + self.password + ' '
	if self.localnames:
	     str = str + "is"
	     for x in self.localnames:
		str = str + " " + x
	     str = str + " here"
	if (self.keep != UserDefaults.keep
		or self.flush != UserDefaults.flush
		or self.fetchall != UserDefaults.fetchall
		or self.rewrite != UserDefaults.rewrite 
		or self.forcecr != UserDefaults.forcecr 
		or self.stripcr != UserDefaults.stripcr 
		or self.pass8bits != UserDefaults.pass8bits
		or self.mimedecode != UserDefaults.mimedecode
		or self.dropstatus != UserDefaults.dropstatus):
	    str = str + " options"
	if self.keep != UserDefaults.keep:
	    str = str + flag2str(self.keep, 'keep')
	if self.flush != UserDefaults.flush:
	    str = str + flag2str(self.flush, 'flush')
	if self.fetchall != UserDefaults.fetchall:
	    str = str + flag2str(self.fetchall, 'fetchall')
	if self.rewrite != UserDefaults.rewrite:
	    str = str + flag2str(self.rewrite, 'rewrite')
	if self.forcecr != UserDefaults.forcecr:
	    str = str + flag2str(self.forcecr, 'forcecr')
	if self.stripcr != UserDefaults.stripcr:
	    str = str + flag2str(self.stripcr, 'stripcr')
	if self.pass8bits != UserDefaults.pass8bits:
	    str = str + flag2str(self.pass8bits, 'pass8bits')
	if self.mimedecode != UserDefaults.mimedecode:
	    str = str + flag2str(self.mimedecode, 'mimedecode')
	if self.dropstatus != UserDefaults.dropstatus:
	    str = str + flag2str(self.dropstatus, 'dropstatus')
	if self.limit != UserDefaults.limit:
	    str = str + " limit " + `self.limit`
	if self.fetchlimit != UserDefaults.fetchlimit:
	    str = str + " fetchlimit " + `self.fetchlimit`
	if self.batchlimit != UserDefaults.batchlimit:
	    str = str + " batchlimit " + `self.batchlimit`
	if self.expunge != UserDefaults.expunge:
	    str = str + " expunge " + `self.expunge`
	if self.mailboxes:
	     str = str + "\n    folder"
	     for x in self.mailboxes:
		str = str + " " + x
	     str = str + " here"
	return str;

    def __str__(self):
	return "[User: " + repr(self) + "]"

#
# Helper code
#

defaultports = {"auto":0,
    		"POP2":109, 
		"POP3":110, "APOP":110, "KPOP":1109, "IMAP":143,
		"IMAP-K4":143,
		"ETRN":25}

protolist = ("auto", "POP2", "POP3", "APOP", "KPOP", "IMAP", "IMAP-K4", "ETRN")

authlist = ("password", "kerberos")

listboxhelp = {
    'title' : 'List Selection Help',
    'banner': 'List Selection',
    'text' : """
You must select an item in the list box (by clicking on it). 
"""}

def flag2str(value, string):
# make a string representation of a .fetchmailrc flag or negated flag
    str = ""
    if value != None:
	str = str + (" ")
	if value == FALSE: str = str + ("no ")
	str = str + string;
    return str

class LabeledEntry(Frame):
# widget consisting of entry field with caption to left
    def bind(self, key, action):
	self.E.bind(key, action)
    def focus_set(self):
	self.E.focus_set()
    def __init__(self, Master, text, textvar, lwidth, ewidth=12):
	Frame.__init__(self, Master)
	self.L = Label(self, {'text':text, 'width':lwidth, 'anchor':'w'})
	self.E = Entry(self, {'textvar':textvar, 'width':ewidth})
	self.L.pack({'side':'left'})
	self.E.pack({'side':'left', 'expand':'1', 'fill':'x'})

def ButtonBar(frame, legend, ref, alternatives, depth, command):
# array of radio buttons, caption to left, picking from a string list
    bar = Frame(frame)
    width = len(alternatives) / depth;
    Label(bar, text=legend).pack(side=LEFT)
    for column in range(width):
	subframe = Frame(bar)
	for row in range(depth):
	    ind = width * row + column
	    Radiobutton(subframe,
			{'text':alternatives[ind], 
			 'variable':ref,
			 'value':alternatives[ind],
			 'command':command}).pack(side=TOP, anchor=W)
	subframe.pack(side=LEFT)
    bar.pack(side=TOP);
    return bar

def helpwin(helpdict):
# help message window with a self-destruct button
    helpwin = Toplevel()
    helpwin.title(helpdict['title']) 
    helpwin.iconname(helpdict['title'])
    Label(helpwin, text=helpdict['banner']).pack()
    textwin = Message(helpwin, text=helpdict['text'], width=600)
    textwin.pack()
    Button(helpwin, text='Done', 
	   command=lambda x=helpwin: Widget.destroy(x),
	   relief=SUNKEN, bd=2).pack()

class ListEdit(Frame):
# edit a list of values (duplicates not allowed) with a supplied editor hook 
    def __init__(self, newlegend, list, editor, master, helptxt):
	self.editor = editor
	self.list = list

	# Set up a widget to accept new elements
	self.newval = StringVar(master)
	newwin = LabeledEntry(master, newlegend, self.newval, '12')
	newwin.bind('<Double-1>', self.handleNew)
	newwin.bind('<Return>', self.handleNew)
	newwin.pack(side=TOP, fill=X, anchor=E)

	# Edit the existing list
	listframe = Frame(master)
	scroll = Scrollbar(listframe)
	self.listwidget = Listbox(listframe, height=0, selectmode='browse')
        if self.list:
            for x in self.list:
                self.listwidget.insert(END, x)
	listframe.pack(side=TOP, expand=YES, fill=BOTH)
	self.listwidget.config(yscrollcommand=scroll.set, relief=SUNKEN)
	self.listwidget.pack(side=LEFT, expand=YES, fill=BOTH)
	scroll.config(command=self.listwidget.yview, relief=SUNKEN)
	scroll.pack(side=RIGHT, fill=BOTH)
	self.listwidget.config(selectmode=SINGLE, setgrid=TRUE)
	self.listwidget.bind('<Double-1>', self.handleList);
	self.listwidget.bind('<Return>', self.handleList);

	bf = Frame(master);
	if self.editor:
	    Button(bf, text='Edit',   command=self.editItem).pack(side=LEFT)
	Button(bf, text='Delete', command=self.deleteItem).pack(side=LEFT)
	if helptxt:
	    self.helptxt = helptxt
	    Button(bf, text='Help', fg='blue',
		   command=self.help).pack(side=RIGHT)
	bf.pack(fill=X)

    def help(self):
	helpwin(self.helptxt)

    def handleList(self, event):
	self.editItem();

    def handleNew(self, event):
	item = self.newval.get()
	entire = self.listwidget.get(0, self.listwidget.index('end'));
	if item and (not entire) or (not item in self.listwidget.get(0, self.listwidget.index('end'))):
	    self.listwidget.insert('end', item)
	    if self.list != None: self.list.append(item)
	self.newval.set('')

    def editItem(self):
	select = self.listwidget.curselection()
	if not select:
	    helpwin(listboxhelp)
	else:
	    index = select[0]
	    if index and self.editor:
		label = self.listwidget.get(index);
		apply(self.editor, (label,))

    def deleteItem(self):
	select = self.listwidget.curselection()
	if not select:
	    helpwin(listboxhelp)
	else:
	    index = select[0]
	    if index:
		self.listwidget.delete(index)
		if self.list != None: del self.list[index]

def ConfirmQuit(frame, context):
    ans = Dialog(frame, 
		 title = 'Quit?',
		 text = 'Really quit ' + context + ' without saving?',
		 bitmap = 'question',
		 strings = ('Yes', 'No'),
		 default = 1)
    return ans.num == 0

def dispose_window(master, legend, help):
    dispose = Frame(master, relief=RAISED, bd=5)
    Label(dispose, text=legend).pack(side=TOP,pady=10)
    Button(dispose, text='Save', fg='blue',
           command=master.save).pack(side=LEFT)
    Button(dispose, text='Quit', fg='blue',
           command=master.nosave).pack(side=LEFT)
    Button(dispose, text='Help', fg='blue',
           command=lambda x=help: helpwin(x)).pack(side=RIGHT)
    dispose.pack(fill=X)
    return dispose

class MyWidget:
# Common methods for Tkinter widgets -- deals with Tkinter declaration
    def post(self, template, field):
	for x in template.typemap:
	    target = "self." + x[0]
	    source = "self." + field + "." + x[0]
	    if x[1] == 'Boolean':
		exec target + " = BooleanVar(self)"
		if eval(source):
		    exec target + ".set(" + source + ")"
	    elif x[1] == 'String':
		exec target + " = StringVar(self)"
		if eval(source):
		    exec target + ".set(" + source + ")"
	    elif x[1] == 'Int':
		exec target + " = IntVar(self)"
		if eval(source):
		    exec target + ".set(" + source + ")"

    def fetch(self, template, field):
	for x in template.typemap:
	    setattr(eval("self." + field), x[0], getattr(self, x[0]).get())

#
# First, code to set the global fetchmail run controls.
#

configure_novice_help = {
    'title' : 'Fetchmail novice configurator help',
    'banner': 'Novice configurator help',
    'text' : """
In the `Novice Configurator Controls' panel, you can:

Press `Save' to save the new fetchmail configuration you have created.
Press `Quit' to exit without saving.
Press `Help' to bring up this help message.

In the `Novice Configuration' panel, you will set up the basic data
needed to create a simple fetchmail setup.  These include:

1. The name of the remote site you want to query.

2. Your login name on that site.

3. Your password on that site.

4. A protocol to use (POP, IMAP, ETRN, etc.)

5. A polling interval.

The novice-configuration code will assume that you want to forward mail
to a local sendmail listener with no special options.
"""}

configure_expert_help = {
    'title' : 'Fetchmail expert configurator help',
    'banner': 'Expert configurator help',
    'text' : """
In the `Expert Configurator Controls' panel, you can:

Press `Save' to save the new fetchmail configuration you have edited.
Press `Quit' to exit without saving.
Press `Help' to bring up this help message.

In the `Run Controls' panel, you can set the following options that
control how fetchmail runs:

Poll interval
        Number of seconds to wait between polls in the background.
        If zero, fetchmail will run in foreground.

Logfile
        If empty, emit progress and error messages to stderr.
        Otherwise this gives the name of the files to write to.
        This field is ignored if the "Log to syslog?" option is on.

Idfile
        If empty, store seen-message IDs in .fetchids under user's home
        directory.  If nonempty, use given file name.

Invisible:
        If false (the default) fetchmail generates a Received line into
        each message and generates a HELO from the machine it is running on.
        If true, fetchmail generates no Received line and HELOs as if it were
        the remote site.

In the `Remote Mail Configurations' panel, you can:

1. Enter the name of a new remote mail server you want fetchmail to query.

To do this, simply enter a label for the poll configuration in the
`New Server:' box.  The label should be a DNS name of the server (unless
you are using ssh or some other tunneling method and will fill in the `via'
option on the site configuration screen).

2. Change the configuration of an existing site.

To do this, find the site's label in the listbox and double-click it.
This will take you to a site configuration dialogue.
"""}


class ConfigurationEdit(Frame, MyWidget):
    def __init__(self, configuration, master=None):
	self.configuration = configuration
        self.container = master
        ConfigurationEdit.mode_to_help = {
            'novice':configure_novice_help, 'expert':configure_expert_help
            }

    def edit(self, mode):
        self.mode = mode
	Frame.__init__(self, self.container)
	self.master.title('fetchmail ' + self.mode + ' configurator');
	self.master.iconname('fetchmail ' + self.mode + ' configurator');
	Pack.config(self)

	self.poll_interval = StringVar(self)
	self.poll_interval.set(`self.configuration.poll_interval`)
	self.syslog = BooleanVar(self)
	self.syslog.set(self.configuration.syslog)
	self.logfile = StringVar(self)

	if self.configuration.logfile: self.logfile.set(self.configuration.logfile);
	self.idfile = StringVar(self)
	if self.configuration.idfile: self.idfile.set(self.configuration.idfile);
	self.invisible = BooleanVar(self)
	self.invisible.set(self.configuration.invisible)
	dispose_window(self,
                       'Configurator ' + self.mode + ' Controls',
                       ConfigurationEdit.mode_to_help[self.mode])

	gf = Frame(self, relief=RAISED, bd = 5)
	Label(gf,
		text='Fetchmail Run Controls', 
		bd=2).pack(side=TOP, pady=10)

        df = Frame(gf)

        # Set the poll interval
        de = LabeledEntry(df, '     Poll interval:', self.poll_interval, '14')
        de.pack(side=RIGHT, anchor=E)
        df.pack()

        if self.mode != 'novice':
            sf = Frame(gf)
            Checkbutton(sf,
		{'text':'Log to syslog?',
		'variable':self.syslog,
		'relief':GROOVE}).pack(side=LEFT, anchor=W)
            log = LabeledEntry(sf, '     Logfile:', self.logfile, '14')
            log.pack(side=RIGHT, anchor=E)
            sf.pack(fill=X)

            Checkbutton(gf,
		{'text':'Invisible mode?',
		'variable':self.invisible,
                 'relief':GROOVE}).pack(side=LEFT, anchor=W)
            # Set the idfile
            log = LabeledEntry(gf, '     Idfile:', self.idfile, '14')
            log.pack(side=RIGHT, anchor=E)

	gf.pack(fill=X)

        # Expert mode allows us to edit multiple sites
	lf = Frame(self, relief=RAISED, bd=5)
	Label(lf,
	      text='Remote Mail Server Configurations', 
	      bd=2).pack(side=TOP, pady=10)
	ListEdit('New Server:', 
		map(lambda x: x.pollname, self.configuration.servers),
		lambda site, m=self.mode, s=self.configuration.servers:
                 ServerEdit(site, s).edit(m, Toplevel()),
                lf, remotehelp)
	lf.pack(fill=X)

    def nosave(self):
	if ConfirmQuit(self, self.mode + " configuration editor"):
	    self.quit()

    # XXX Someday this must go to the actual config file location
    def save(self):
        self.fetch(Controls, 'configuration')
	sys.stdout.write("# Configuration created %s\n" % time.ctime(time.time()))
	sys.stdout.write(`self.configuration`)
	self.quit()

#
# Server editing stuff.
#
remotehelp = {
    'title' : 'Remote site help',
    'banner': 'Remote sites',
    'text' : """
When you add a site name to the list here, 
you initialize an entry telling fetchmail
how to poll a new site.

When you select a sitename (by double-
clicking it, or by single-clicking to
select and then clicking the Edit button),
you will open a window to configure that
site.
"""}

serverhelp = {
    'title' : 'Server options help',
    'banner': 'Server Options',
    'text' : """
The server options screen controls fetchmail 
options that apply to one of your mailservers.

Once you have a mailserver configuration set
up as you like it, you can select `Save' to
store it in the server list maintained in
the main configuration window.

If you wish to discard changes to a server 
configuration, select `Quit'.
"""}

controlhelp = {
    'title' : 'Run Control help',
    'banner': 'Run Controls',
    'text' : """
If the `Poll normally' checkbox is on, the host is polled as part of
the normal operation of fetchmail when it is run with no arguments.
If it is off, fetchmail will only query this host when it is given as
a command-line argument.

The `True name of server' box should specify the actual DNS name
to query. By default this is the same as the poll name.

Normally each host described in the file is queried once each 
poll cycle. If `Cycles to skip between polls' is greater than 0,
that's the number of poll cycles that are skipped between the
times this post is actually polled.

The `Server timeout' is the number of seconds fetchmail will wait
for a reply from the mailserver before concluding it is hung and
giving up.
"""}

protohelp = {
    'title' : 'Protocol and Port help',
    'banner': 'Protocol and Port',
    'text' : """
These options control the remote-mail protocol
and TCP/IP service port used to query this
server.

The `Protocol' button bar offers you a choice of
all the different protocols available.  The `auto'
protocol is a special mode that probes the host
ports for POP3 and IMAP to see if either is
available.

Normally the TCP/IP service port to use is 
dictated by the protocol choice.  The `Port'
field (only present in expert mode) lets you
set a non-standard port.
"""}

sechelp = {
    'title' : 'Security option help',
    'banner': 'Security',
    'text' : """
The `interface' option, if given, specifies the only
device through which fetchmail is permitted to connect
to servers.  Specifying this may protect you from a 
spoofing attack if your client machine has more than
one IP gateway address and some of the gateways are
to insecure nets.

The `monitor' option allows you to specify a range
of IP addresses to monitor for activity.  If these
addresses are not active, fetchmail will not poll.
This option may be used to prevent fetchmail from
triggering an expensive dial-out if the interface
is not already active.

The `interface' and `monitor' options are available
only for Linux systems.  See the fetchmail manual page
for details on these.
"""}

multihelp = {
    'title' : 'Multidrop option help',
    'banner': 'Multidrop',
    'text' : """
These options are only useful with multidrop mode.
See the manual page for extended discussion.
"""}

suserhelp = {
    'title' : 'User list help',
    'banner': 'User list',
    'text' : """
When you add a user name to the list here, 
you initialize an entry telling fetchmail
to poll the site on behalf of the new user.

When you select a username (by double-
clicking it, or by single-clicking to
select and then clicking the Edit button),
you will open a window to configure the
user's options on that site.
"""}

class ServerEdit(Frame, MyWidget):
    def __init__(self, host, servers):
	self.server = None
	for site in servers:
	    if site.pollname == host:
		self.server = site
	if (self.server == None):
		self.server = Server()
		self.server.pollname = host
		self.server.via = host
		servers.append(self.server)

    def edit(self, mode, master=None):
	Frame.__init__(self, master)
	Pack.config(self)
	self.master.title('Fetchmail host ' + self.server.pollname);
	self.master.iconname('Fetchmail host ' + self.server.pollname);
	self.post(Server, 'server')
	self.makeWidgets(self.server.pollname, mode)
#	self.grab_set()
#	self.focus_set()
#	self.wait_window()

    def nosave(self):
	if ConfirmQuit(self, 'server option editing'):
	    Widget.destroy(self.master)

    def save(self):
	self.fetch(Server, 'server')
	Widget.destroy(self.master)

    def refreshPort(self):
	proto = self.protocol.get()
	self.port.set(defaultports[proto])
	if not proto in ("POP3", "APOP", "KPOP"): self.uidl = FALSE

    def makeWidgets(self, host, mode):
	topwin = dispose_window(self, "Server options for querying " + host, serverhelp)

	leftwin = Frame(self);
	leftwidth = '25';

        if mode != 'novice':
            ctlwin = Frame(leftwin, relief=RAISED, bd=5)
            Label(ctlwin, text="Run Controls").pack(side=TOP)
            Checkbutton(ctlwin, text='Poll ' + host + ' normally?', variable=self.active).pack(side=TOP)
            LabeledEntry(ctlwin, 'True name of ' + host + ':',
		      self.via, leftwidth).pack(side=TOP, fill=X)
            LabeledEntry(ctlwin, 'Cycles to skip between polls:',
		      self.interval, leftwidth).pack(side=TOP, fill=X)
            LabeledEntry(ctlwin, 'Server timeout (seconds):',
		      self.timeout, leftwidth).pack(side=TOP, fill=X)
            Button(ctlwin, text='Help', fg='blue',
	       command=lambda: helpwin(controlhelp)).pack(side=RIGHT)
            ctlwin.pack(fill=X)

	protwin = Frame(leftwin, relief=RAISED, bd=5)
	Label(protwin, text="Protocol").pack(side=TOP)
	pb = ButtonBar(protwin, '', self.protocol, protolist, 2, self.refreshPort) 
        if mode != 'novice':
            LabeledEntry(protwin, 'On server TCP/IP port:',
		      self.port, leftwidth).pack(side=TOP, fill=X)
            Checkbutton(protwin,
		text="POP3: track `seen' with client-side UIDLs?",
		variable=self.uidl).pack(side=TOP)   
	Button(protwin, text='Help', fg='blue',
	       command=lambda: helpwin(protohelp)).pack(side=RIGHT)
	protwin.pack(fill=X)

	userwin = Frame(leftwin, relief=RAISED, bd=5)
	Label(userwin, text="User entries for " + host).pack(side=TOP)
	ListEdit("New user: ",
                 map(lambda x: x.remote, self.server.users),
                 lambda u, m=mode, s=self.server: UserEdit(u,s).edit(m, Toplevel()),
                 userwin, suserhelp)
	userwin.pack(fill=X)

	leftwin.pack(side=LEFT, anchor=N, fill=X);

        if mode != 'novice':
            rightwin = Frame(self);

            mdropwin = Frame(rightwin, relief=RAISED, bd=5)
            Label(mdropwin, text="Multidrop options").pack(side=TOP)
            LabeledEntry(mdropwin, 'Envelope address header:',
		      self.envelope, '22').pack(side=TOP, fill=X)
            LabeledEntry(mdropwin, 'Envelope headers to skip:',
		      self.envskip, '22').pack(side=TOP, fill=X)
            LabeledEntry(mdropwin, 'Name prefix to strip:',
		      self.qvirtual, '22').pack(side=TOP, fill=X)
            Checkbutton(mdropwin, text="Enable multidrop DNS lookup?",
		    variable=self.dns).pack(side=TOP)
            Label(mdropwin, text="DNS aliases").pack(side=TOP)
            ListEdit("New alias: ", self.server.aka, None, mdropwin, None)
            Label(mdropwin, text="Domains to be considered local").pack(side=TOP)
            ListEdit("New domain: ",
		 self.server.localdomains, None, mdropwin, multihelp)
            mdropwin.pack(fill=X)

            secwin = Frame(rightwin, relief=RAISED, bd=5)
            Label(secwin, text="Security").pack(side=TOP)
            # Don't actually let users set this.  KPOP sets it implicitly
            #	ButtonBar(secwin, 'Authorization mode:',
            #		  self.auth, authlist, 1, None).pack(side=TOP)
            if os.popen("uname").readlines()[0] == 'Linux\n':
                LabeledEntry(secwin, 'Interface to check before poll:',
			 self.interface, leftwidth).pack(side=TOP, fill=X)
                LabeledEntry(secwin, 'IP range to monitor:',
			 self.monitor, leftwidth).pack(side=TOP, fill=X)
            Button(secwin, text='Help', fg='blue',
	       command=lambda: helpwin(sechelp)).pack(side=RIGHT)
            secwin.pack(fill=X)

            rightwin.pack(side=LEFT, anchor=N);

#
# User editing stuff
#

userhelp = {
    'title' : 'User option help',
    'banner': 'User options',
    'text' : """
You may use this panel to set options
that may differ between individual
users on your site.

Once you have a user configuration set
up as you like it, you can select `Save' to
store it in the server list maintained in
the main configuration window.

If you wish to discard the changes you have
made to user options, select `Quit'.
"""}

localhelp = {
    'title' : 'Local name help',
    'banner': 'Local names',
    'text' : """
The local name(s) in a user entry are the
people on the client machine who should
receive mail from the poll described.

Note: if a user entry has more than one
local name, messages will be retrieved
in multidrop mode.  This complicates
the configuration issues; see the manual
page section on multidrop mode.
"""}

class UserEdit(Frame, MyWidget):
    def __init__(self, username, server):
        self.server = server
	self.user = None
	for user in server.users:
	    if user.remote == username:
		self.user = user
	if self.user == None:
	    self.user = User()
	    self.user.remote = user
	    self.user.localnames = [user]
	    server.users.append(self.user)

    def edit(self, mode, master=None):
	Frame.__init__(self, master)
	Pack.config(self)
	self.master.title('Fetchmail user ' + self.user.remote
                          + ' querying ' + self.server.pollname);
	self.master.iconname('Fetchmail user ' + self.user.remote);
	self.post(User, 'user')
	self.makeWidgets(mode, self.server.pollname)
#	self.grab_set()
#	self.focus_set()
#	self.wait_window()

    def nosave(self):
	if ConfirmQuit(self, 'user option editing'):
	    Widget.destroy(self.master)

    def save(self):
	self.fetch(User, 'user')
	Widget.destroy(self.master)

    def makeWidgets(self, mode, servername):
	dispose_window(self,
			"User options for " + self.user.remote + " querying " + servername,
			userhelp)

        if mode != 'novice':
            leftwin = Frame(self);
        else:
            leftwin = self

        secwin = Frame(leftwin, relief=RAISED, bd=5)
        Label(secwin, text="Authentication").pack(side=TOP)
        LabeledEntry(secwin, 'Password:',
		      self.password, '12').pack(side=TOP, fill=X)
        secwin.pack(fill=X, anchor=N)

        names = Frame(leftwin, relief=RAISED, bd=5)
        Label(names, text="Local names").pack(side=TOP)
        ListEdit("New name: ",
                     self.user.localnames, None, names, localhelp)
        names.pack(fill=X, anchor=N)

        if mode != 'novice':
            targwin = Frame(leftwin, relief=RAISED, bd=5)
            Label(targwin, text="Forwarding Options").pack(side=TOP)
            Label(targwin, text="Listeners to forward to").pack(side=TOP)
            ListEdit("New listener:", self.user.smtphunt, None, targwin, None)
            LabeledEntry(targwin, 'Append to MAIL FROM line:',
		     self.smtpaddress, '26').pack(side=TOP, fill=X)
            LabeledEntry(targwin, 'Connection setup command:',
		     self.preconnect, '26').pack(side=TOP, fill=X)
            LabeledEntry(targwin, 'Connection wrapup command:',
		     self.postconnect, '26').pack(side=TOP, fill=X)
            LabeledEntry(targwin, 'Local delivery agent:',
		     self.mda, '26').pack(side=TOP, fill=X)
            LabeledEntry(targwin, 'Listener spam-block code:',
		     self.antispam, '26').pack(side=TOP, fill=X)
            targwin.pack(fill=X, anchor=N)

        if mode != 'novice':
            leftwin.pack(side=LEFT, fill=X, anchor=N)
            rightwin = Frame(self)
        else:
            rightwin = self

	optwin = Frame(rightwin, relief=RAISED, bd=5)
	Label(optwin, text="Processing Options").pack(side=TOP)
	Checkbutton(optwin, text="Suppress deletion of messages after reading",
		    variable=self.keep).pack(side=TOP, anchor=W)
	Checkbutton(optwin, text="Fetch old messages as well as new",
		    variable=self.fetchall).pack(side=TOP, anchor=W)
        if mode != 'novice':
            Checkbutton(optwin, text="Flush seen messages before retrieval", 
		    variable=self.flush).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Rewrite To/Cc/Bcc messages to enable reply", 
		    variable=self.rewrite).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Force CR/LF at end of each line",
		    variable=self.forcecr).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Strip CR from end of eacgh line",
		    variable=self.stripcr).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Pass 8 bits even though SMTP says 7BIT",
		    variable=self.pass8bits).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Undo MIME armoring on header and body",
		    variable=self.mimedecode).pack(side=TOP, anchor=W)
            Checkbutton(optwin, text="Drop Status lines from forwarded messages", 
		    variable=self.dropstatus).pack(side=TOP, anchor=W)
	optwin.pack(fill=X)

        if mode != 'novice':
            limwin = Frame(rightwin, relief=RAISED, bd=5)
            Label(limwin, text="Resource Limits").pack(side=TOP)
            LabeledEntry(limwin, 'Message size limit:',
		      self.limit, '30').pack(side=TOP, fill=X)
            LabeledEntry(limwin, 'Max messages to fetch per poll:',
		      self.fetchlimit, '30').pack(side=TOP, fill=X)
            LabeledEntry(limwin, 'Max messages to forward per poll:',
		      self.batchlimit, '30').pack(side=TOP, fill=X)
            LabeledEntry(limwin, 'Interval between expunges (IMAP):',
		      self.expunge, '30').pack(side=TOP, fill=X)
            limwin.pack(fill=X)

            foldwin = Frame(rightwin, relief=RAISED, bd=5)
            Label(foldwin, text="Remote folders (IMAP only)").pack(side=TOP)
            ListEdit("New folder:", self.user.mailboxes, None, foldwin, None)
            foldwin.pack(fill=X, anchor=N)

        if mode != 'novice':
            rightwin.pack(side=LEFT)
        else:
            self.pack()


#
# Top-level window that offers either novice or expert mode
# (but not both at once; it disappears when one is selected).
#

class MainWindow(Frame):
    def __init__(self, master=None):
	Frame.__init__(self, master)
	self.master.title('fetchmail configurator main');
	self.master.iconname('fetchmail configurator main');
	Pack.config(self)
	Label(self,
		text='Configurator Main Window', 
		bd=2).pack(side=TOP, pady=10)

	Message(self, text="""
Use `Novice Configuration' for basic fetchmail setup;
with this, you can easily set up a single-drop connection
to one remote mail server.
""", width=600).pack(side=TOP)
	Button(self, text='Novice Configuration',
				fg='blue', command=self.novice).pack()

	Message(self, text="""
Use `Expert Configuration' for advanced fetchmail setup,
including multiple-site or multidrop connections.
""", width=600).pack(side=TOP)
	Button(self, text='Expert Configuration',
				fg='blue', command=self.expert).pack()

	Message(self, text="""
Or you can just select `Quit' to leave the configurator now.
""", width=600).pack(side=TOP)
	Button(self, text='Quit', fg='blue', command=self.leave).pack()

    def novice(self):
	self.destroy()
	ConfigurationEdit(Configuration).edit('novice')

    def expert(self):
	self.destroy()
	ConfigurationEdit(Configuration).edit('expert')

    def leave(self):
        self.quit()

#
# And this is the main sequence
#

def intersect(list1, list2):
# Compute set intersection of lists
    res = []
    for x in list1:
	if x in list2:
	    res.append(x)
    return res

def setdiff(list1, list2):
# Compute set difference of lists
    res = []
    for x in list1:
	if not x in list2:
	    res.append(x)
    return res

def copy_instance(toclass, fromdict):
# Initialize a class object of given type from a conformant dictionary.
    class_sig = toclass.__dict__.keys(); class_sig.sort()
    dict_keys = fromdict.keys(); dict_keys.sort()
    common = intersect(class_sig, dict_keys)
    if 'typemap' in class_sig: 
	class_sig.remove('typemap')
    if tuple(class_sig) != tuple(dict_keys):
	print "Conformability error"
#	print "Class signature: " + `class_sig`
#	print "Dictionary keys: " + `dict_keys`
	print "Not matched in class signature: " + `setdiff(class_sig, common)`
	print "Not matched in dictionary keys: " + `setdiff(dict_keys, common)`
	sys.exit(1)
    else:
	for x in dict_keys:
	    setattr(toclass, x, fromdict[x])

if __name__ == '__main__': 

    # Compute defaults
    ControlDefaults = Controls()
    ServerDefaults = Server()
    UserDefaults = User()

    # Read the existing configuration
    tmpfile = "/tmp/fetchmailconf." + `os.getpid()`
    os.system("fetchmail --configdump >" + tmpfile)
    execfile(tmpfile)
    os.remove(tmpfile)

    # The tricky part -- initializing objects from the configuration global
    # `Configuration' is the top level of the object tree we're going to mung 
    Configuration = Controls()
    copy_instance(Configuration, configuration)
    Configuration.servers = [];
    for server in configuration['servers']:
	Newsite = Server()
	copy_instance(Newsite, server)
	Configuration.servers.append(Newsite)
	Newsite.users = [];
	for user in server['users']:
	    Newuser = User()
	    copy_instance(Newuser, user)
	    Newsite.users.append(Newuser)

    # We may want to display the configuration and quit
    if len(sys.argv) > 1 and sys.argv[1] == '-d':
        print "This is a dump of the configuration we read:\n"+`Configuration`
        sys.exit(0)

    # OK, now run the configuration edit
    MainWindow().mainloop()

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
